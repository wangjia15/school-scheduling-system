export interface WebSocketMessage {\n  type: string\n  payload: any\n  timestamp: string\n  userId?: number\n}\n\nexport interface ScheduleUpdateMessage {\n  type: 'SCHEDULE_CREATED' | 'SCHEDULE_UPDATED' | 'SCHEDULE_DELETED' | 'SCHEDULE_CONFLICT'\n  scheduleId: number\n  semester: string\n  academicYear: string\n  teacherId?: number\n  classroomId?: number\n  courseId?: number\n  conflict?: {\n    id: number\n    type: string\n    severity: string\n    description: string\n  }\n}\n\nexport interface TeacherUpdateMessage {\n  type: 'TEACHER_CREATED' | 'TEACHER_UPDATED' | 'TEACHER_DELETED' | 'TEACHER_AVAILABILITY_CHANGED'\n  teacherId: number\n  employeeId: string\n  name: string\n}\n\nexport interface ClassroomUpdateMessage {\n  type: 'CLASSROOM_CREATED' | 'CLASSROOM_UPDATED' | 'CLASSROOM_DELETED' | 'CLASSROOM_MAINTENANCE'\n  classroomId: number\n  roomNumber: string\n  building: string\n}\n\nexport interface SystemNotificationMessage {\n  type: 'SYSTEM_ALERT' | 'MAINTENANCE_SCHEDULED' | 'BACKUP_COMPLETED' | 'PERFORMANCE_WARNING'\n  title: string\n  message: string\n  severity: 'INFO' | 'WARNING' | 'ERROR' | 'SUCCESS'\n  actionUrl?: string\n}\n\nexport interface UserActivityMessage {\n  type: 'USER_LOGIN' | 'USER_LOGOUT' | 'SCHEDULE_GENERATION_STARTED' | 'SCHEDULE_GENERATION_COMPLETED'\n  userId: number\n  username: string\n  action: string\n  details?: any\n}\n\ntype MessageHandler = (message: WebSocketMessage) => void\n\nclass WebSocketService {\n  private ws: WebSocket | null = null\n  private reconnectAttempts = 0\n  private maxReconnectAttempts = 5\n  private reconnectDelay = 1000\n  private isConnected = false\n  private messageHandlers: Map<string, MessageHandler[]> = new Map()\n  private reconnectTimer: NodeJS.Timeout | null = null\n  private heartbeatTimer: NodeJS.Timeout | null = null\n\n  constructor() {\n    // Initialize connection when service is created\n    this.connect()\n  }\n\n  connect() {\n    try {\n      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:'\n      const host = import.meta.env.VITE_WS_HOST || window.location.host\n      const wsUrl = `${protocol}//${host}/ws`\n\n      this.ws = new WebSocket(wsUrl)\n\n      this.ws.onopen = this.handleOpen.bind(this)\n      this.ws.onmessage = this.handleMessage.bind(this)\n      this.ws.onclose = this.handleClose.bind(this)\n      this.ws.onerror = this.handleError.bind(this)\n\n    } catch (error) {\n      console.error('WebSocket connection error:', error)\n      this.scheduleReconnect()\n    }\n  }\n\n  private handleOpen() {\n    console.log('WebSocket connected')\n    this.isConnected = true\n    this.reconnectAttempts = 0\n    \n    // Start heartbeat\n    this.startHeartbeat()\n    \n    // Send authentication message\n    this.authenticate()\n  }\n\n  private handleMessage(event: MessageEvent) {\n    try {\n      const message: WebSocketMessage = JSON.parse(event.data)\n      \n      // Reset heartbeat timer\n      this.resetHeartbeat()\n      \n      // Route message to appropriate handlers\n      const handlers = this.messageHandlers.get(message.type) || []\n      handlers.forEach(handler => handler(message))\n      \n      // Log message for debugging\n      if (import.meta.env.DEV) {\n        console.log('WebSocket message received:', message)\n      }\n      \n    } catch (error) {\n      console.error('Error parsing WebSocket message:', error)\n    }\n  }\n\n  private handleClose(event: CloseEvent) {\n    console.log('WebSocket disconnected:', event.code, event.reason)\n    this.isConnected = false\n    this.cleanup()\n    \n    if (event.code !== 1000) { // 1000 = normal closure\n      this.scheduleReconnect()\n    }\n  }\n\n  private handleError(error: Event) {\n    console.error('WebSocket error:', error)\n    this.isConnected = false\n    this.cleanup()\n    this.scheduleReconnect()\n  }\n\n  private authenticate() {\n    const token = localStorage.getItem('token')\n    if (token) {\n      this.send({\n        type: 'AUTHENTICATE',\n        payload: { token }\n      })\n    }\n  }\n\n  private startHeartbeat() {\n    this.heartbeatTimer = setInterval(() => {\n      if (this.isConnected) {\n        this.send({\n          type: 'HEARTBEAT',\n          payload: { timestamp: Date.now() }\n        })\n      }\n    }, 30000) // Send heartbeat every 30 seconds\n  }\n\n  private resetHeartbeat() {\n    if (this.heartbeatTimer) {\n      clearTimeout(this.heartbeatTimer as any)\n      this.startHeartbeat()\n    }\n  }\n\n  private cleanup() {\n    if (this.heartbeatTimer) {\n      clearInterval(this.heartbeatTimer)\n      this.heartbeatTimer = null\n    }\n    \n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer)\n      this.reconnectTimer = null\n    }\n  }\n\n  private scheduleReconnect() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts)\n      \n      console.log(`Scheduling reconnect attempt ${this.reconnectAttempts + 1} in ${delay}ms`)\n      \n      this.reconnectTimer = setTimeout(() => {\n        this.reconnectAttempts++\n        this.connect()\n      }, delay)\n    } else {\n      console.error('Max reconnection attempts reached')\n    }\n  }\n\n  send(message: Omit<WebSocketMessage, 'timestamp'>) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      const fullMessage: WebSocketMessage = {\n        ...message,\n        timestamp: new Date().toISOString()\n      }\n      this.ws.send(JSON.stringify(fullMessage))\n    } else {\n      console.warn('WebSocket not connected, cannot send message')\n    }\n  }\n\n  subscribe(messageType: string, handler: MessageHandler) {\n    if (!this.messageHandlers.has(messageType)) {\n      this.messageHandlers.set(messageType, [])\n    }\n    \n    this.messageHandlers.get(messageType)!.push(handler)\n    \n    // Return unsubscribe function\n    return () => {\n      const handlers = this.messageHandlers.get(messageType)\n      if (handlers) {\n        const index = handlers.indexOf(handler)\n        if (index > -1) {\n          handlers.splice(index, 1)\n        }\n      }\n    }\n  }\n\n  unsubscribe(messageType: string, handler: MessageHandler) {\n    const handlers = this.messageHandlers.get(messageType)\n    if (handlers) {\n      const index = handlers.indexOf(handler)\n      if (index > -1) {\n        handlers.splice(index, 1)\n      }\n    }\n  }\n\n  subscribeToScheduleUpdates(handler: (message: ScheduleUpdateMessage) => void) {\n    return this.subscribe('SCHEDULE_UPDATE', (message) => {\n      handler(message.payload as ScheduleUpdateMessage)\n    })\n  }\n\n  subscribeToTeacherUpdates(handler: (message: TeacherUpdateMessage) => void) {\n    return this.subscribe('TEACHER_UPDATE', (message) => {\n      handler(message.payload as TeacherUpdateMessage)\n    })\n  }\n\n  subscribeToClassroomUpdates(handler: (message: ClassroomUpdateMessage) => void) {\n    return this.subscribe('CLASSROOM_UPDATE', (message) => {\n      handler(message.payload as ClassroomUpdateMessage)\n    })\n  }\n\n  subscribeToSystemNotifications(handler: (message: SystemNotificationMessage) => void) {\n    return this.subscribe('SYSTEM_NOTIFICATION', (message) => {\n      handler(message.payload as SystemNotificationMessage)\n    })\n  }\n\n  subscribeToUserActivity(handler: (message: UserActivityMessage) => void) {\n    return this.subscribe('USER_ACTIVITY', (message) => {\n      handler(message.payload as UserActivityMessage)\n    })\n  }\n\n  requestScheduleUpdates(semester: string, academicYear: string) {\n    this.send({\n      type: 'SUBSCRIBE_SCHEDULE_UPDATES',\n      payload: { semester, academicYear }\n    })\n  }\n\n  requestConflictUpdates() {\n    this.send({\n      type: 'SUBSCRIBE_CONFLICT_UPDATES',\n      payload: {}\n    })\n  }\n\n  requestTeacherUpdates() {\n    this.send({\n      type: 'SUBSCRIBE_TEACHER_UPDATES',\n      payload: {}\n    })\n  }\n\n  requestClassroomUpdates() {\n    this.send({\n      type: 'SUBSCRIBE_CLASSROOM_UPDATES',\n      payload: {}\n    })\n  }\n\n  disconnect() {\n    if (this.ws) {\n      this.ws.close(1000, 'Disconnect requested')\n      this.ws = null\n    }\n    this.cleanup()\n  }\n\n  get connected() {\n    return this.isConnected\n  }\n}\n\n// Create singleton instance\nexport const websocketService = new WebSocketService()\n\n// Auto-connect when the service is imported\nif (typeof window !== 'undefined') {\n  // Reconnect on page visibility change\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible' && !websocketService.connected) {\n      websocketService.connect()\n    }\n  })\n}\n\nexport type {\n  WebSocketMessage,\n  ScheduleUpdateMessage,\n  TeacherUpdateMessage,\n  ClassroomUpdateMessage,\n  SystemNotificationMessage,\n  UserActivityMessage\n}